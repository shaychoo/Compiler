package IC.Parser;

import java_cup.runtime.*;
import IC.AST.*;
import IC.*;

import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
parser code {:


	/**
	 * Causes the parsr to print every token it reads. useful for debugging
	 */
	public boolean printTokens;

	private Lexer lexer;

	public Parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}

	public int getLine() {
		return lexer.getLineNumber();
	}

	public void syntax_error(Symbol s) {
		Token token = (Token) s;
		System.out.println("Line " + token.getLine()+": Syntax error; unexpected " + token.getTokenValue());
	}
:};
// This is just for debugging
scan with {:
	Token t = lexer.next_token();
	if (printTokens)
		System.out.println(t.getLine() + ":" + t.getVal());
	return t;
:};

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

non terminal Program program;
non terminal ICClass class;
non terminal List<ICClass> class_list;
non terminal Field	field;
non terminal List<Field> fields;
non terminal List<Field> fieldsinrow;
non terminal Method	method;
non terminal Type	type;
non terminal Formal formal;
non terminal List<Formal> formals;
non terminal Statement statement;
non terminal StatementsBlock stmt_list;
non terminal If ifStatement;
non terminal Expression expr;
non terminal List<Expression> exprlist, actualParams, properActualParams;
non terminal Type returnType;
non terminal ClassContents classcontents;
non terminal Location location;
non terminal Call call;
non terminal Literal literal;
non terminal StaticCall staticCall;
non terminal VirtualCall virtualCall;



terminal String INTEGER; // change to integer
terminal String  QUOTE;
terminal String IDENT, CLASS_ID;
terminal String FALSE, TRUE; // change to integer
terminal LENGTH, NEQUAL, EQUAL, RP, SEMI, DOT, LP, PLUS, MINUS, MULTIPLY, DIVIDE, GT, GTE, LT, LTE, LB, LCBR, RCBR, RB, LNEG, LAND, LOR, MOD, COMMA,
		 IF, ASSIGN, BREAK, CLASS, CONTINUE, EXTENDS, ELSE, NEW, RETURN, THIS, VOID, WHILE, STATIC;
terminal INT, STRING, BOOLEAN, UMINUS;
terminal NULL;


//////////////////////////
// Precedence declarations

precedence right ASSIGN;
precedence left LOR;
precedence left LAND;
precedence left EQUAL, NEQUAL;
precedence left GTE, GT, LT, LTE;
precedence left MINUS, PLUS;
precedence left MULTIPLY, DIVIDE, MOD;
precedence right UMINUS, LNEG;
precedence left DOT, LP, RP, LB, RB;

//////////////
// The grammar

program ::= class_list:cl
      {: RESULT = new Program(cl); :}
;

class_list ::= class:c {:
      	RESULT = new ArrayList<ICClass>(); RESULT.add(c);
      :}
      	| class_list:cl class:c
      {: cl.add(c); RESULT = cl; :}
;

class ::= CLASS CLASS_ID:name EXTENDS CLASS_ID:superclassico LCBR classcontents:cc RCBR {:
		RESULT = new ICClass(parser.getLine(),name,superclassico, cc.getFields(), cc.getMethods());
	:} |
	CLASS CLASS_ID:name LCBR classcontents:cc RCBR {:
		RESULT = new ICClass(parser.getLine(),name, cc.getFields(), cc.getMethods());
	:}
;


classcontents ::=
	fields:f {:
		ClassContents cc = new ClassContents();
		List<Field> fields = cc.getFields();
		fields.addAll(f);
		cc.setFields(fields);
		RESULT = cc;
	 :} |
	 method:m {:
		ClassContents cc = new ClassContents();
		List<Method> methods = cc.getMethods();
		methods.add(m);
		cc.setMethods(methods);
		RESULT = cc;
	 :} |
	 classcontents:cc fields:f {:
	 	List<Field> fields = cc.getFields();
	 	fields.addAll(f);
	 	cc.setFields(fields);
		RESULT = cc;
	 :} | classcontents:cc method:m {:
	 	List<Method> methods = cc.getMethods();
		methods.add(m);
		cc.setMethods(methods);
		RESULT = cc;
	 :}
;


fields ::= fieldsinrow:row SEMI {: RESULT = row; :}
;

fieldsinrow ::=
		field:f {:
			ArrayList<Field> list = new ArrayList<Field>();
			list.add(f);
			RESULT = list; :} |
		fieldsinrow:row COMMA IDENT:id {:
			Field field = new Field(row.get(0).getType(), id);
			row.add(field);
			RESULT = row;
		:}
;

field ::=
	      type:t IDENT:id {:
   		  	RESULT = new Field(t,id); :}
;

method ::=  STATIC type:t IDENT:f LP formals:formals RP LCBR stmt_list:st RCBR  {:
				RESULT = new StaticMethod(t,f,formals, st.getStatements()); :} |
			type:t IDENT:f LP formals:formals RP LCBR stmt_list:st RCBR  {:
				RESULT = new VirtualMethod(t,f,formals, st.getStatements()); :} |
			STATIC type:t IDENT:f LP RP LCBR stmt_list:st RCBR  {:
				RESULT = new StaticMethod(t,f,new ArrayList<Formal>(), st.getStatements()); :} |
			type:t IDENT:f LP RP LCBR stmt_list:st RCBR  {:
				RESULT = new VirtualMethod(t,f,new ArrayList<Formal>(), st.getStatements()); :} |
			STATIC VOID IDENT:f LP formals:formals RP LCBR stmt_list:st RCBR  {:
				RESULT = new StaticMethod(new PrimitiveType(parser.getLine(), DataTypes.VOID),f,formals, st.getStatements()); :} |
			VOID IDENT:f LP formals:formals RP LCBR stmt_list:st RCBR  {:
				RESULT = new VirtualMethod(new PrimitiveType(parser.getLine(), DataTypes.VOID),f,formals, st.getStatements()); :} |
			STATIC VOID IDENT:f LP RP LCBR stmt_list:st RCBR  {:
				RESULT = new StaticMethod(new PrimitiveType(parser.getLine(), DataTypes.VOID),f,new ArrayList<Formal>(), st.getStatements()); :} |
			VOID IDENT:f LP RP LCBR stmt_list:st RCBR  {:
				RESULT = new VirtualMethod(new PrimitiveType(parser.getLine(), DataTypes.VOID),f,new ArrayList<Formal>(), st.getStatements()); :}
;

formal ::= type:t IDENT:id {: RESULT = new Formal(t,id); :}
;

formals ::= formal:fo {:
			ArrayList<Formal> flist = new ArrayList<Formal>();
			flist.add(fo); RESULT = flist; :}
			|
			formals:flist COMMA formal:fo {:
			flist.add(fo); RESULT = flist; :}
;



type ::= INT {:
		RESULT = new PrimitiveType(parser.getLine(), DataTypes.INT);:} |
	    STRING {: RESULT = new PrimitiveType(parser.getLine(), DataTypes.STRING);:} |
	    BOOLEAN{: RESULT = new PrimitiveType(parser.getLine(), DataTypes.BOOLEAN);:} |
	    CLASS_ID:c {: RESULT = new UserType(parser.getLine(), c); :} |
		type:t LB RB {:
			t.incrementDimension();
			RESULT = t;
		:}
;

expr ::=
			expr:e1 PLUS expr:e2 {:
				RESULT = new MathBinaryOp(e1,BinaryOps.PLUS,e2); :} |
			expr:e1 MINUS expr:e2 {:
				RESULT = new MathBinaryOp(e1,BinaryOps.MINUS,e2); :} |
			expr:e1 MULTIPLY expr:e2 {:
				RESULT = new MathBinaryOp(e1,BinaryOps.MULTIPLY,e2); :} |
			expr:e1 DIVIDE expr:e2 {:
				RESULT = new MathBinaryOp(e1,BinaryOps.DIVIDE,e2); :} |
			expr:e1 MOD expr:e2 {:
				RESULT = new MathBinaryOp(e1,BinaryOps.MOD,e2); :} |
			expr:e1 EQUAL expr:e2 {:
				RESULT = new MathBinaryOp(e1,BinaryOps.EQUAL,e2); :} |
			expr:e1 NEQUAL expr:e2 {:
				RESULT = new MathBinaryOp(e1,BinaryOps.NEQUAL,e2); :} |
			expr:e1 GT expr:e2 {:
				RESULT = new MathBinaryOp(e1,BinaryOps.GT,e2); :} |
			expr:e1 GTE expr:e2 {:
				RESULT = new MathBinaryOp(e1,BinaryOps.GTE,e2); :} |
			expr:e1 LT expr:e2 {:
				RESULT = new MathBinaryOp(e1,BinaryOps.LT,e2); :} |
			expr:e1 LTE expr:e2 {:
				new MathBinaryOp(e1,BinaryOps.LTE,e2); :} |
			expr:e1 LAND expr:e2 {:
				RESULT = new LogicalBinaryOp(e1,BinaryOps.LAND,e2); :} |
			expr:e1 LOR expr:e2 {:
				RESULT = new LogicalBinaryOp(e1,BinaryOps.LOR,e2); :} |
			LNEG expr:e1 {:
				RESULT = new LogicalUnaryOp(UnaryOps.LNEG,e1); :} |
			MINUS expr:e1  {:
				RESULT = new MathUnaryOp(UnaryOps.UMINUS,e1); :} %prec UMINUS |
			IDENT:f LP exprlist:args RP {:
				RESULT = new VirtualCall(parser.getLine(),f,args); :} |
			expr:arr DOT LENGTH {:
				RESULT = new Length(arr); :} |
			QUOTE:str {:
				RESULT = new Literal(parser.getLine(),LiteralTypes.STRING,str); :} |
			LP expr:e1 RP {: RESULT = new ExpressionBlock(e1); :} |
			NEW:id CLASS_ID:name LP RP SEMI {: RESULT = new NewClass(parser.getLine(),name); :} |
			NEW:id type:name LB expr:size RB SEMI {: RESULT = new NewArray(name,size); :} |
			location:e {: RESULT = e;:} |
			call:e {:RESULT = e;:} |
			THIS {:
				RESULT = new This(parser.getLine());:}  |
			INTEGER:x {:
				RESULT = new Literal(parser.getLine(), LiteralTypes.INTEGER, x);:} |
			TRUE:x {:
				RESULT = new Literal(parser.getLine(),LiteralTypes.TRUE);:}  |
			FALSE:x {:
				RESULT = new Literal(parser.getLine(),LiteralTypes.FALSE);:}  |
			NULL:x {:
				RESULT = new Literal(parser.getLine(),LiteralTypes.NULL);:}
;

exprlist ::= expr:e {:
			List<Expression> list = new ArrayList<Expression>();
			list.add(e);
			RESULT = list; :} |
 			 exprlist:list COMMA expr:e{:
 			 	list.add(e);
 			 	RESULT = list;
 			 :}
;

stmt_list ::=  statement:st  {:
		List<Statement> temp = new ArrayList<Statement>(); temp.add(st);
		RESULT = new StatementsBlock(parser.getLine(),temp);
	:} 	|
		stmt_list:s1 statement:s {:
		List<Statement> temp = s1.getStatements();
		temp.add(s);
		RESULT = new StatementsBlock(parser.getLine(), temp);
	:}

;

statement ::= 	IF LP expr:e RP statement:s ELSE statement:es {:
					RESULT = new If(e,s,es);:}  |
				IF LP expr:e RP statement:s {:
					RESULT = new If(e,s);:} |
				WHILE LP expr:e RP statement:s {:
					RESULT = new While(e,s);:} |
				BREAK:b SEMI {:
					RESULT = new Break(parser.getLine()); :} |
				CONTINUE SEMI {:
					RESULT = new Continue(parser.getLine()); :} |
				RETURN expr:e SEMI {:
					RESULT = new Return(parser.getLine(),e); :} |
				RETURN:e SEMI {:
					RESULT = new Return(parser.getLine()); :} |
				IDENT:f LP exprlist:args RP SEMI {:
					RESULT = new CallStatement(new VirtualCall(parser.getLine(),f,args)); :} |
				type:t IDENT:id ASSIGN expr:e SEMI {:
					Location loc = new VariableLocation(parser.getLine(),id);
					RESULT = new Assignment(loc,e); :}  |
				type:t IDENT:id SEMI {:
					RESULT = new LocalVariable(t,id); :} |
				call:c SEMI {:
					RESULT = new CallStatement(c);
				:} |
				location:loc ASSIGN expr:e SEMI {:
					RESULT = new Assignment(loc,e);
				:}|
				LCBR statement:s RCBR
				{:
				    RESULT = s;
				:}

				|
                LCBR  RCBR
                {:
                    RESULT = new EmptyStatement(parser.getLine());
                :}
;

location ::=	IDENT:id {:
					RESULT = new VariableLocation(parser.getLine(), id);:} |
			  	expr:e DOT IDENT:id {:
			  		RESULT = new VariableLocation(parser.getLine(), e, id); :} |
			  	expr:arr LB expr:index RB {:
			  		RESULT = new ArrayLocation(arr,index); :}
;

call ::= 	staticCall:c {:
				RESULT = c;
			:} |
			virtualCall:c {:
				RESULT = c;
			:} ;

staticCall ::= CLASS_ID:c DOT IDENT:f LP exprlist:args RP {:
				RESULT = new StaticCall(parser.getLine(),c, f,args);  :}
;

virtualCall ::= expr:e DOT IDENT:f LP exprlist:args RP {:
					RESULT = new VirtualCall(parser.getLine(),e,f,args);:} |
				IDENT:name LP actualParams:args RP {:
					RESULT = new VirtualCall(parser.getLine(),name,args);:}
;