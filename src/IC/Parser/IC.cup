package IC.Parser;

import java_cup.runtime.*;
import IC.AST.*;

import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;

parser code  {:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	public boolean printTokens;

	private Lexer lexer;

	public Parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}

	public int getLine() {
		return lexer.getLineNumber();
	}

	public void syntax_error(Symbol s) {
		Token tok = (Token) s;
		System.out.println("Line " + tok.getLine()+": Syntax error; unexpected " + tok);
	}
:}

// This is just for debugging
scan with {:
	Token t = lexer.next_token();
	if (printTokens)
		System.out.println(t.getLine() + ":" + t);
	return t;
:};




////////////////////////////////////////////
// Symbol list (terminals and non-terminals)



//////////////////////////
// Precedence declarations

//////////////
// The grammar

non terminal Program program;
non terminal Literal literal;
non terminal Expression expr;
non terminal Statement statement;
non terminal StatementsBlock statementsBlock;
non terminal List<ICClass> class_list;
non terminal ICClass class;
non terminal ClassContents classcontents;
non terminal Field fields;
non terminal Method method;



terminal LP,RP,ASSIGN,BOOLEAN,BREAK,COMMA,CONTINUE,DIVIDE;
terminal DOT,EQUAL,EXTENDS,FALSE,ELSE,GT,GTE,IF,INT,LAND;
terminal LB,LCBR,LENGTH,LNEG,LOR,LT,LTE,MINUS,MOD,MULTIPLY;
terminal NEQUAL,NULL,PLUS,RB,RCBR,RETURN,SEMI,STATIC,CLASS;
terminal THIS,TRUE,VOID,WHILE,STRING,CLASS_ID,IDENT,NEW,QUOTE;

terminal READI, PRINT;
terminal Integer NUMBER;
terminal String VAR;
terminal Integer INTEGER;


precedence left LOR;
precedence left LAND;
precedence left PLUS, MINUS;
precedence left DIVIDE, MULTIPLY;
precedence left MINUS;
precedence left GT, LT, GTE, LTE;


program ::= class_list:cl
      {: RESULT = new Program( cl); :}
;

class_list ::= class:c
      {: RESULT = new LinkedList<ICClass>();
         RESULT.add(c);
      :}
      | class_list:cl class:c
      {: cl.add(c); RESULT = cl; :}
;


class ::=

      CLASS CLASS_ID:className LCBR RCBR
      {: RESULT = new ICClass(parser.getLine(),className == null ? "no name" : className.toString(), new ArrayList<Field>(), new ArrayList<Method>());
      :}
        | CLASS CLASS_ID:className LCBR classcontents:cc RCBR
      {: RESULT = new ICClass(parser.getLine(),className == null ? "no name" : className.toString(), cc.getFields(), cc.getMethods());
      :}
      |
      CLASS CLASS_ID:className EXTENDS CLASS_ID:extendClassName  LCBR classcontents:cc  RCBR
        {: RESULT = new ICClass(parser.getLine(), className.toString(),extendClassName.toString(),cc.getFields(), cc.getMethods());
        :}
        |
      CLASS CLASS_ID:className EXTENDS CLASS_ID:extendClassName  LCBR   RCBR
        {: RESULT = new ICClass(parser.getLine(),className.toString(),extendClassName.toString(), new ArrayList<Field>(), new ArrayList<Method>());
        :}
;




classcontents ::=
	fields:f {:
		ClassContents cc = new ClassContents();
		List<Field> fields = cc.getFields();
		fields.add(f);
		cc.setFields(fields);
		RESULT = cc;
	 :} |
	 method:m {:
	 //parser.getLine()
		ClassContents cc = new ClassContents();
		List<Method> methods = cc.getMethods();
		methods.add(m);
		cc.setMethods(methods);
		RESULT = cc;
	 :} |
	 classcontents:cc fields:f {:
	 	List<Field> fields = cc.getFields();
	 	fields.add(f);
	 	cc.setFields(fields);
		RESULT = cc;
	 :} | classcontents:cc method:m {:
	 	List<Method> methods = cc.getMethods();
		methods.add(m);
		cc.setMethods(methods);
		RESULT = cc;
	 :}
;
