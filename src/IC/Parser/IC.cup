package IC.Parser;

import IC.AST.*;

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

//nonterminal Program Program;

//terminal         ASSIGN;
//terminal Integer INTEGER;


//////////////////////////
// Precedence declarations

//////////////
// The grammar

//Literal ::= INTEGER | NULL;




//package slp;

import java_cup.runtime.*;

parser code  {:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	public boolean printTokens;

	private Lexer lexer;

	public Parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}

	public int getLine() {
		return lexer.getLineNumber();
	}

	public void syntax_error(Symbol s) {
		Token tok = (Token) s;
		System.out.println("Line " + tok.getLine()+": Syntax error; unexpected " + tok);
	}
:}

// This is just for debugging
scan with {:
	Token t = lexer.next_token();
	if (printTokens)
		System.out.println(t.getLine() + ":" + t);
	return t;
:};

terminal PLUS, MINUS, MULTIPLY, DIVIDE, LP, RP, SEMI, ASSIGN, GT, LT, GTE, LTE, LAND, LOR;
terminal READI, PRINT;
terminal Integer NUMBER;
terminal String VAR;
terminal UMINUS;

non terminal Expr expr;
non terminal Stmt stmt;
non terminal StmtList stmt_list;

precedence left LOR;
precedence left LAND;
precedence left PLUS, MINUS;
precedence left DIVIDE, MULTIPLY;
precedence left UMINUS;
precedence left GT, LT, GTE, LTE;

stmt_list ::= stmt:s
	{: RESULT = new StmtList(s); :}
	| stmt_list:sl stmt:s
	{: sl.addStmt(s); RESULT = sl; :}
;

stmt ::= VAR:v ASSIGN expr:e SEMI
	{: VarExpr ve = new VarExpr(v); RESULT = new AssignStmt(ve, e); :}
	| PRINT LP expr:e RP SEMI
	{: RESULT = new PrintStmt(e); :}
;

expr ::= expr:e1 PLUS:p expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.PLUS);
		   System.out.println("Reduced rule e1 + e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 MINUS expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.MINUS);
		   System.out.println("Reduced rule e1 - e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 MULTIPLY expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.MULTIPLY);
		   System.out.println("Reduced rule e1 * e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 DIVIDE expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.DIVIDE);
		   System.out.println("Reduced rule e1 / e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 LAND expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.LAND);
		   System.out.println("Reduced rule e1 && e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 LOR expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.LOR);
		   System.out.println("Reduced rule e1 || e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 LT expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.LT);
		   System.out.println("Reduced rule e1 < e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 GT expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.GT);
		   System.out.println("Reduced rule e1 > e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 LTE expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.LTE);
		   System.out.println("Reduced rule e1 <= e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| expr:e1 GTE expr:e2
		{: RESULT = new BinaryOpExpr(e1, e2, Operator.GTE);
		   System.out.println("Reduced rule e1 >= e2 for e1=" + e1 + " and e2="+e2);
		 :}
		| MINUS expr:e1
		{: RESULT = new UnaryOpExpr(e1, Operator.MINUS); :} %prec UMINUS
		| LP expr:e RP
		{: RESULT = e; :}
		| NUMBER:n
		{: RESULT = new NumberExpr(n.intValue()); :}
		| READI LP RP
		{: RESULT = new ReadIExpr(); :}
		| VAR:v
		{: RESULT = new VarExpr(v); :}
;


